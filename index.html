<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>3d2</title>
  <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" />
  <script src="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700"></script>
  <link href='http://fonts.googleapis.com/css?family=Titillium+Web' rel='stylesheet' type='text/css'>
  <style>
  * {
    box-sizing: border-box;
  }
  canvas {
    border: 1px solid black;
    position: relative;
    position: inline-block;
    position: absolute;
    z-index: -1;
  }
  .map-controls {
    display: block;
    width: 10%;
    z-index: 1;
  }
  .left-panel {
    vertical-align: top;
  }
  button {
    width: 5em;
    height: 4em;
    border-radius: 5px;
    background-color: lightBlue;
  }
  .display {
    background-color: HoneyDew;
  }
  @media(max-width: 1000px) {
    button {
      border-radius: 1em;
      border: 1px solid black;
      background-color: white;
      outline: none;
      font-size: 2em;
    }
    .panel{
      font-size: 4em;
    }
  }
  .panel {
    border: 1px solid black;
    border-radius: 0em;
    position: absolute;
    bottom: 0;
    width: 101%;
    height: 35%;
    margin: 0 auto;
    text-align: center;
    font-family: 'Titillium Web', sans-serif;
    /* Height of the footer */
    font-size: 2em;
    background: AliceBlue;
  }
  #mainBody{width:80%}
  .arrow{width:10%;}
  .left{position:absolute;text-align:left;float:left}
  .right{float:right;}
  .centre{
    width: 80%;
    display: block;
    margin-left: auto;
    margin-right: auto;
  }
</style>
</head>

<body>
  <canvas id="canvas-map"></canvas>

  <table id="map-controls">
    <tr>
      <td>
        <button id="buttonZoomIn" class="btn btn-default btn-large"><i class="glyphicon glyphicon-zoom-in"></i></button>

      </td>
    </tr>
    <tr>
      <td>
        <button id="buttonZoomOut" class="btn btn-default btn-large"><i class="glyphicon glyphicon-zoom-out"></i></button>

      </td>
    </tr>
  </table>
  <div class="panel">
    <h2 id="mainTitle" ></h2>
    <div class="arrow left"><i class="glyphicon glyphicon-chevron-left"></i>
    </div>
    <span id="mainBody" ></span>
  </div>

  <script>
    // ☰
    cc = function(a) {
      console.log(a)
    }
    var canvas1 = document.getElementById("canvas-map")
    // var moveLeft  = document.getElementById("buttonLeft")
    // var moveRight = document.getElementById("buttonRight")
    // var moveUp    = document.getElementById("buttonUp")
    // var moveDown  = document.getElementById("buttonDown")
    var ctx = canvas1.getContext("2d")
    canvas1.width = innerWidth;
    canvas1.height = innerHeight * 2 / 3;
    var centerX = canvas1.width / 2,
    centerY = canvas1.height / 2,
    π = Math.PI,
    τ = 2 * π,
    sqrt = Math.sqrt,
    cos = Math.cos,
    sin = Math.sin,
    rnd = Math.round,
    fps = 10,
    timer = 0,
    eye = 200,
    scale = 1,
    // rotation counters
    ix = 60,
    iy = 60,
    iz = 60,
    // rotation target values at end of rotation
    degIncr = π / 6 / fps, //30degrees rotated in 1 second @30fps
    incrX = degIncr / 3,
    incrY = degIncr / 3, //target
    zoomIncr = 1 / fps,
    incrZ = zoomIncr,
    zMin = .1,
    totalx = 0,
    totaly = 0,
    totalz = 0,
    mouseX = 0,
    mouseY = 0;
    canvas1.onmousemove = function(d) {
      mouseX = d.clientX;
      mouseY = d.clientY
    }
alert(2)
    function toggleTimer() {
      if (timer === 0) {
        timer = setInterval(main, fps)
      }
    } //turn animation on if it is off
    //document.getElementById("buttonRight").onclick = function() {
    //  if (ix && incrX > 0) return null // disallaw if buttonLeft is active
    //  incrX = -degIncr;
    //  ix += fps;
    //  toggleTimer()
    //}
    //document.getElementById("buttonLeft").onclick = function() {
    //  if (ix && incrX < 0) return null
    //  incrX = degIncr;
    //  ix += fps;
    //  toggleTimer()
    //}

    document.getElementsByClassName("panel")[0].onclick = function() {
      if (ix && incrX < 0) return null
      incrX = degIncr;
      ix += fps;
      toggleTimer()
    }
    ///document.getElementById("buttonDown").onclick = function() {
    //  if (iy && incrY > 0) return null // d
    //  incrY = -degIncr;
    //  iy += fps;
    //  toggleTimer()
    //}
    //document.getElementById("buttonUp").onclick = function() {
    //  if (iy && incrY < 0) return null
    //  incrY = degIncr;
    //  iy += fps;
    //  toggleTimer()
    //}
    document.getElementById("buttonZoomOut").onclick = function() {
      if (iz && incrZ > 0) return null // d
      incrZ = -zoomIncr;
      iz += fps;
      toggleTimer()
    }
    document.getElementById("buttonZoomIn").onclick = function() {
      if (iz && incrZ < 0) return null
      incrZ = zoomIncr;
      iz += fps;
      toggleTimer()
    }
    //------------------------------------------------------------------------------
    function sinc(x, y) {
      //y += 10
      var mag = sqrt(x * x + y * y)
      var res = -60 * (sin(mag) / mag || 1)
      if (mag === 0)
      res = -60
      return res
    }

    function terr(x, y) {
      return sinc(x, y) + sinc(x + -3, y + -1) + sinc(x - -1, y + -3)
    }

    function makeGrid(gridSize) {
      var ix, iy, z, tic = +new Date(),
      grid = [],
      count = 0,
      endValue = 10, // actual value of end  point
      nPoints = gridSize * 3 + 1, // 1/2 points not including 0
      rowLength = nPoints * 2 + 1,
      stretch = endValue / nPoints,
      fillView = 100 / nPoints //100px either side of centre
      for (iy = -nPoints; iy <= nPoints; iy++)
      for (ix = -nPoints; ix <= nPoints; ix++) {
        z = terr(ix * stretch, iy * stretch)
        var pp = {
          count: count++,
          x: ix * fillView,
          y: iy * fillView,
          z: z,
          h: (z < 0) ? 0 : z,
          _x: 0,
          _y: 0,
          detail: 0
        }
        grid.push(pp)
      }
      cc("rowLength " + rowLength)
      cc("grid.length " + grid.length)
      cc("grid.length/4 " + grid.length / 4)
      cc("grid.length/4 " + Math.sqrt(grid.length / 4))
      return {
        grid: grid,
        rowLength: rowLength,
        fn: terr,
        stretch: stretch,
        fillView: fillView,
        createGridTime: (+new Date() - tic)
      }
    }

    function adjustShore(plane, factor) {
      /*      3 . 2 . 9
      . . . . .
      4 . 1 . 8
      . . . . .
      5 . 6 . 7
      */
      var ix, iy, p1, i1, i2, i3, i4, i5, i6, i7, i8, i9, grid = plane.grid,
      fn = plane.fn,
      rowLength = plane.rowLength,
      stretch = plane.stretch,
      fillView = plane.fillView,
      abs = Math.abs,
      ddx = Math.abs(grid[1].x - grid[0].x),
      ddy = Math.abs(grid[1].y - grid[0].y),
      minxy = Math.max(abs(ddx), abs(ddy)),
      minDistance = Math.sqrt(ddx * ddx + ddy * ddy) || minxy
      for (iy = 1; iy < rowLength - 1; iy += 1)
      for (ix = 1; ix < rowLength - 1; ix += 1) {
        i1 = ix + iy * rowLength
        i2 = i1 - rowLength
        i3 = i1 - rowLength - 1
        i4 = i1 - 1
        i5 = i1 + rowLength - 1
        i6 = i1 + rowLength
        i7 = i1 + rowLength + 1
        i8 = i1 + 1
        i9 = i1 - rowLength + 1
        p1 = grid[i1]
        if (
        (p1.z * grid[i2].z) < 0 ||
        (p1.z * grid[i3].z) < 0 ||
        (p1.z * grid[i4].z) < 0 ||
        (p1.z * grid[i5].z) < 0 ||
        (p1.z * grid[i6].z) < 0 ||
        (p1.z * grid[i7].z) < 0 ||
        (p1.z * grid[i8].z) < 0 ||
        (p1.z * grid[i9].z) < 0
        ) {
          secantMethod2(p1, fn, minDistance, stretch, fillView, factor)
        } else {}
      }
    }

    function directionAscent(x, y, fn) {
      var tiny = 1e-7,
      PI = Math.PI,
      abs = Math.abs,
      y0 = fn(x, y),
      y1 = fn(x + tiny, y),
      y2 = fn(x, y + tiny),
      dx = y1 - y0,
      dy = y2 - y0,
      mag = Math.sqrt(dx * dx + dy * dy),
      // the angle is not needed but ...
      angle = Math.atan(abs(dy / dx))
      if (dx > 0 && dy > 0) { //I
        angle = angle
      } else if (dx < 0 && dy > 0) { //II
        angle = PI - angle
      } else if (dx < 0 && dy < 0) { //III
        angle = PI + angle
      } else if (dx > 0 && dy < 0) { //IV
        angle = -angle
      }
      return [dx / mag, dy / mag, angle /* radians */ ]
    }

    function secantMethod2(p1, fn, minDistance, stretch, fillView, factor) { //fast,
      /* fn(x,y)
      finds zeros between t.p.
      */
      var z0, z1, dx, dy, x, x1, y1, distMoved,
      x0 = p1.x / fillView * stretch,
      y0 = p1.y / fillView * stretch,
      x00 = x0,
      y00 = y0,
      count = 0,
      maxIter = 20, // usually 8 iter stop
      dir = directionAscent(x0, y0, fn), // [dx,dy,angle]
      dx = dir[0] / 1000,
      dy = dir[1] / 1000,
      dydx = dir[1] / dir[0],
      x1 = x0 + dx,
      y1 = y0 + dy,
      z0 = 0
      while (maxIter-- && x1 !== x0) {
        z0 = fn(x0, y0)
        z1 = fn(x1, y1)
        x = x1 - z1 * (x1 - x0) / (z1 - z0)
        x0 = x1
        y0 = y1
        x1 = (isNaN(x)) ? x0 : x
        y1 = (x - x00) * dydx + y00
      }
      dx = x1 - x00
      dy = y1 - y00
      distMoved = Math.sqrt(dx * dx + dy * dy)
      if (distMoved < minDistance / factor && (typeof z1 != 'undefined')) {
        p1.x = x1 * fillView / stretch
        p1.y = y1 * fillView / stretch
        p1.z = z1
        p1.detail = 1
        p1.h = (z1 < 0) ? 0 : z1
      } else {
        return false
      }
      return x0
    }

    function main() {
      var tic = +new Date()
      if (ix) {
        ix--;
        totalx += incrX
      }
      if (iy) {
        iy--;
        totaly += incrY
      }
      if (iz) {
        iz--;
        totalz += incrZ;
        if (totalz < zMin) totalz = zMin
      }
      if (ix < 1 && iy < 1 && iz < 1) { // check all animation increment countdowns
        clearInterval(timer);
        timer = 0
        showTitle()
      }
      world.forEach(rotate)
      draw(world[0])
    }

    function rotate(plane) {
      var x, y, z, x1, y1, z1, pnt, scale,
      grid = plane.grid, //grid
      rowLength = plane.rowLength,
      cosθx = cos(totalx),
      sinθx = sin(totalx),
      cosθy = cos(totaly),
      sinθy = sin(totaly),
      ip = grid.length;
      while (ip--) {
        pnt = grid[ip] //global
        x = pnt.x
        y = pnt.y
        z = pnt.z
        x1 = x * cosθx - y * sinθx //rotate in xy
        y1 = x * sinθx + y * cosθx
        y = y1
        y1 = y * cosθy - z * sinθy //rotate in yz
        z1 = y * sinθy + z * cosθy
        scale = totalz / (1 - z1 / eye) // zoom = totalz
        pnt._x = centerX + x1 * scale
        pnt._y = centerY + y1 * scale
      }
    }
    initialRun = 1

    function draw(plane) {
      var ix, iy, p1, p2, p3, p4, i1, i2, i3, i4, p12, p14, p23, p34, pMid,
      grid = plane.grid,
      rowLength = plane.rowLength,
      skip = 2, // make sure it is divisible
      r2 = rowLength * skip
      /*      3 . 2           3  23   2
      . M .          34  Mi  12
      4 . 1           4  14   1
      */
      ctx.clearRect(0, 0, canvas1.width, canvas1.height);
      for (iy = skip; iy < rowLength; iy += skip)
      for (ix = skip; ix < rowLength; ix += skip) {
        i1 = ix + iy * rowLength
        i2 = i1 - r2
        i3 = i1 - r2 - skip
        i4 = i1 - skip
        p1 = grid[i1]
        p2 = grid[i2]
        p3 = grid[i3]
        p4 = grid[i4]
        p12 = grid[(i1 + i2) / 2]
        p14 = grid[(i1 + i4) / 2]
        p23 = grid[(i3 + i2) / 2]
        p34 = grid[(i3 + i4) / 2]
        pMid = grid[(i3 + i1) / 2]
        if (!p1.details) {
          //ctx.strokeStyle = "grey";
          ctx.fillStyle = p1.color;
          ctx.beginPath();
          ctx.moveTo(p1._x, p1._y)
          ctx.lineTo(p12._x, p12._y)
          ctx.lineTo(p2._x, p2._y)
          ctx.lineTo(p23._x, p23._y)
          ctx.lineTo(p3._x, p3._y)
          ctx.lineTo(p34._x, p34._y)
          ctx.lineTo(p4._x, p4._y)
          ctx.lineTo(p14._x, p14._y)
          ctx.lineTo(p1._x, p1._y)
          ctx.fill();
        }
        //ctx.closePath();
        if (initialRun &&
        p12.detail ||
        p14.detail ||
        p23.detail ||
        p34.detail ||
        pMid.detail
        ) {
          p1.detail = 1
        }
        //ctx.stroke()
        if (p1.detail) {
          //ctx.strokeStyle = "grey";
          ctx.fillStyle = p1.color;
          ctx.beginPath();
          ctx.moveTo(p1._x, p1._y)
          ctx.lineTo(p12._x, p12._y)
          ctx.lineTo(pMid._x, pMid._y)
          ctx.lineTo(p14._x, p14._y)
          ctx.closePath();
          //ctx.stroke()
          ctx.fill()
          ctx.beginPath();
          ctx.fillStyle = p12.color;
          ctx.moveTo(p12._x, p12._y)
          ctx.lineTo(p2._x, p2._y)
          ctx.lineTo(p23._x, p23._y)
          ctx.lineTo(pMid._x, pMid._y)
          ctx.closePath();
          //ctx.stroke()
          ctx.fill()
          ctx.beginPath();
          ctx.moveTo(pMid._x, pMid._y)
          ctx.fillStyle = pMid.color;
          ctx.lineTo(p23._x, p23._y)
          ctx.lineTo(p3._x, p3._y)
          ctx.lineTo(p34._x, p34._y)
          ctx.closePath();
          //ctx.stroke()
          ctx.fill()
          ctx.beginPath();
          ctx.fillStyle = p14.color;
          ctx.moveTo(p14._x, p14._y)
          ctx.lineTo(pMid._x, pMid._y)
          ctx.lineTo(p34._x, p34._y)
          ctx.lineTo(p4._x, p4._y)
          ctx.closePath();
          //ctx.stroke()
          ctx.fill()
        } //if p1.detail
      } //for
      initialRun = 0
    } //function
    function writeNumbers(plane) {
      var grid = plane.grid,
      i = grid.length
      while (i--) {
        p1 = grid[i]
        //if(p1.x===0)
        ctx.fillStyle = "black"
        ctx.fillText(p1.count, p1._x, p1._y)
        ctx.fillStyle = "white"
        ctx.fillText(p1.count, p1._x + 1, p1._y + 1)
      }
    }
    onkeydown = function(e) {
      //alert('I work!!' + 'you pressed keyCode: ' + e.keyCode)
      //js1k eye of beholder
      // if this is a keydown event, keyDOWN gets the value 1, otherwise 0
      //cc("e:"+e.keyCode)
      var keyDOWN = e.type[5] ? 1 : 0,
      key = e.keyCode
      if (key === 37) moveLEFT()
      if (key === 39) moveRIGHT()
      if (key === 38) moveUP()
      if (key === 40) moveDOWN()
    }

    function move_planes(x, y) {
      for (var nP = 0; nP < world.length; nP++) {
        var p = world[nP].grid; //grab next plane from array
        var p1 = p.length;
        while (p1--) {
          p[p1].x += x;
          p[p1].y += y;
        }
      } //end moving all planes
    }

    function moveUP() {
      move_planes(0, 1);
      draw(world[0]);
      toggleTimer()
    }

    function moveDOWN() {
      move_planes(0, -0.7);
      draw(world[0]);
      toggleTimer()
    }

    function moveRIGHT() {
      move_planes(0.7, 0);
      draw(world[0]);
      toggleTimer()
    }

    function moveLEFT() {
      move_planes(-0.7, 0);
      draw(world[0]);
      toggleTimer()
    }

    function addColor(plane) {
      var ix, iy, p1, i1, i2, i3, i4, avz,
      grid = plane.grid,
      rowLength = plane.rowLength,
      skip = 1, // make sure it is divisible
      r2 = rowLength * skip,
      snowLevel = 100
      for (iy = skip; iy < rowLength; iy += skip)
      for (ix = skip; ix < rowLength; ix += skip) {
        i1 = ix + iy * rowLength
        i2 = i1 - r2
        i3 = i1 - r2 - skip
        i4 = i1 - skip
        avz = (grid[i1].z + grid[i2].z + grid[i3].z + grid[i4].z) / 4 || 0
        grid[i1].debug = [i1, i2, i3, i4, grid[i1].z, grid[i2].z, grid[i3].z, grid[i4].z]
        //if(grid[i1].x===0)cc(grid[i1].count)
        grid[i1].color = colorize(avz, snowLevel, grid[i1], plane.fn, plane.fillView, plane.stretch)
      }
    }

    function colorize(z, snowLevel, p1, fn, fillView, stretch) {
      var r, g, b,
      seaLevel = 0,
      round = Math.round,
      x = p1.x / fillView * stretch,
      y = p1.y / fillView * stretch,
      tiny = 0.000001,
      z0 = fn(x, y),
      z1 = fn(x, y - tiny),
      dz = z1 - z0,
      dx = tiny, //* 1.41421356237,
      sun = dz / dx * 12
      r = -z + 30
      g = -z + 45
      b = -z + 30 // green hills
      if (z > snowLevel) {
        r = 180 - z * 2
        g = 180 - z * 2
        b = 180 - z * 2
      } //tallest==white
      if (z < seaLevel) {
        r = 255 + z * 3
        g = 255 + z * 2
        b = 255 + z / 2 + 100
      } //ocean=blue
      if (z > seaLevel) {
        r = r + sun;
        g = g + sun;
        b = b + sun;
      }
      r = (r > 255) ? 255 : r;
      g = (g > 255) ? 255 : g;
      b = (b > 255) ? 255 : b;
      r = (r < 0) ? 0 : r;
      g = (g < 0) ? 0 : g;
      b = (b < 0) ? 0 : b;
      r = round(r);
      g = round(g);
      b = round(b);
      p1.avz = z
      return "rgb(" + r + "," + g + "," + b + ")"
    }

    function showStuff(plane) {
      var grid = plane.grid
      for (var i = 0; i < grid.length; i++) {
        var p = grid[i]
        //if(p.x===0){
        if (p.x === p.y)
        cc("________________")
        cc("i:" + i + " x:" + p.x + " y:" + p.y + " color:" + p.color + " avz:" + p.avz)
        cc("z: " + p.z)
        //}
      }
    }

    function zeroSea(plane) {
      var grid = plane.grid,
      p
      for (var i = 0; i < grid.length; i++) {
        p = grid[i]
        if (p.z < 0) p.z = 0
      }
    }
    var titlePage = 0
    var panelColor =  "#006699"
    var panelTitles =[ "ABOUT", "PROJECTS", "PROJECTS", "CONTACT", ]
    var panelBodies =[
    "I am a full-stack Ruby on Rails Web-Developer",

    "<h3>Bike Tracker</h3><p>An App made with Andre and Michael.  I created the 3D visualisation and interface with Google Maps</p>",

    "<h3>Angular Game</h3>A Front-End game created using Angular.<br>  This is a preview, stay tuned",

    "The fastest way to get a response from me is to send me an email.<br>"+
    " I will try to respond to your email in less than 24 hours."+

    "<br><a href='mailto:someone@example.com?Subject=Hello%20again' target='_top'>vasko.traikovski@gmail.com</a>", ]
    function showTitle() {

      if (titlePage > 3)
      titlePage = 0
      var title = document.getElementById("mainTitle");
      var main = document.getElementById("mainBody");
      title.innerHTML = ( panelTitles[titlePage] ); //"#D93600"
      main.innerHTML = ( panelBodies[titlePage] ); //"#D93600"
      //title.style.backgroundColor = panelColors[titlePage];
      title.style.color = panelColor;
      titlePage++
      //0099CC
    }
    var terrain = makeGrid(15)
    cc("time create " + terrain.createGridTime)
    //if(terrain.createGridTime>20 ) terrain = makeGrid(40)
    // if(terrain.createGridTime>15 ) terrain = makeGrid(6)
    world = [terrain]
    terrainDetail = makeGrid(10)
    adjustShore(world[0], 10)
    addColor(world[0])
    zeroSea(world[0])
    //showStuff(world[0])
    toggleTimer()
  </script>
</body>

</html>
