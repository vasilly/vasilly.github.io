<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>3d2</title>
  <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" />
  <style>
  canvas {
    position: absolute;
    border: 1px solid black;
  }
  #map-controls {
    display: block;
    z-index: 1;
  }
  .sample {
    position: absolute;
    /*position         : relative;*/

    display: block;
  }
  button {
    width: 4em;
    height: 3em;
    border-radius: 0.3em;
    border: 1px solid black;
    background-color: white;
    outline: none;
  }
  @media(max-width: 1000px) {
    button {
      border-radius: 1em;
      border: 1px solid black;
      background-color: white;
      outline: none;
      font-size: 2em;
    }
  }
  </style>
</head>

<body>
  <canvas id="canvas-map"></canvas>
  <table id="map-controls">
    <tr>
      <td>
        <button class="btn btn-default btn-large">
          </i><span>fps<br></span><span id="msgtop1"></span> </button>

      </td>
      <td>
        <button class="btn btn-default btn-large">
          </i><span>time<br></span><span id="msgtop2"></span> </button>

      </td>
      <td>
        <button class="btn btn-default btn-large">
          </i><span>time<br></span><span id="msgtop3"></span> </button>

      </td>
    </tr>

    <tr>
      <td>
        <button id="buttonLeftFast" class="btn btn-default btn-large"><i class="glyphicon glyphicon-backward"></i>
        </button>

      </td>
      <td>
        <button id="buttonUp" class="btn btn-default btn-large"><i class="glyphicon glyphicon-arrow-up"></i>
        </button>
      </td>
      <td>
        <button id="buttonRightFast" class="btn btn-default btn-large"><i class="glyphicon glyphicon-forward"></i>
        </button>

      </td>
    </tr>

    <tr>
      <td>
        <button id="buttonLeft" class="btn btn-default btn-large"><i class="glyphicon glyphicon-arrow-left"></i>
        </button>
      </td>
      <td>

      </td>
      <td>
        <button id="buttonRight" class="btn btn-default btn-large"><i class="glyphicon glyphicon-arrow-right"></i>
        </button>
      </td>
    </tr>

    <tr>
      <td>
        <button id="buttonZoomIn" class="btn btn-default btn-large"><i class="glyphicon glyphicon-zoom-in"></i>
        </button>
      </td>
      <td>
        <button id="buttonDown" class="btn btn-default btn-large"><i class="glyphicon glyphicon-arrow-down"></i>
        </button>
      </td>
      <td>
        <button id="buttonZoomOut" class="btn btn-default btn-large"><i class="glyphicon glyphicon-zoom-out"></i>
        </button>
      </td>
    </tr>

  </table>
  ⤴ ⤵ ⤶ ⤷ ⤸ ⤹ ￩ ￪ ￫ ￬
  <div id="msg"></div>
  <div class="sample">asdjfklajsfkljafldkjdaf</div>
  <script>
  cc = function(a) {
    console.log(a)
  }
  var canvas1 = document.getElementById("canvas-map")
  var ctx = canvas1.getContext("2d")
  canvas1.width = innerWidth;
  canvas1.height = innerHeight * 0.8;
  var centerX = canvas1.width / 2,
    centerY = canvas1.height / 2,
    l = [],
    π = Math.PI,
    τ = 2 * π,
    sqrt = Math.sqrt,
    cos = Math.cos,
    sin = Math.sin,
    round = Math.round,
    floor = Math.floor,
    abs = Math.abs,
    fps = 30,
    timer = 0,
    eye = 200,
    scale = 1,
    ix = 0,
    iy = 60,
    iz = 60,
    degIncr = π / 6 / fps, //30degrees rotated in 1 second @30fps
    incrX = 0,
    incrY = degIncr,
    zoomIncr = 1 / fps,
    incrZ = zoomIncr,
    zoom = 1,
    zMin = .1,
    totalx = 0,
    totaly = 0,
    totalz = 0,
    mouseX = 0,
    mouseY = 0;

  canvas1.onmousemove = function(d) {
    mouseX = d.clientX;
    mouseY = d.clientY;
  };

  function toggleTimer() {
      if (timer === 0) {
        timer = setInterval(main, fps)
      }
    } //turn on if off
  document.getElementById("buttonRight").onclick = function() {
    if (ix && incrX > 0)
      return null; // only allow multiple klicks from same button
    incrX = -degIncr;
    ix += fps;
    toggleTimer();
  }
  document.getElementById("buttonRightFast").onclick = function() {
    if (ix && incrX > 0)
      return null; // only allow multiple klicks from same button
    incrX = -degIncr * 2;
    ix += fps * 3;
    toggleTimer();
  }
  document.getElementById("buttonLeft").onclick = function() {
    if (ix && incrX < 0)
      return null;
    incrX = degIncr;
    ix += fps;
    toggleTimer();
  }
  document.getElementById("buttonLeftFast").onclick = function() {
    if (ix && incrX < 0)
      return null;
    incrX = degIncr * 2;
    ix += fps * 3;
    toggleTimer();
  }
  document.getElementById("buttonDown").onclick = function() {
    if (iy && incrY > 0)
      return null;
    incrY = -degIncr;
    iy += fps;
    toggleTimer();
  }
  document.getElementById("buttonUp").onclick = function() {
    if (iy && incrY < 0)
      return null;
    incrY = degIncr;
    iy += fps;
    toggleTimer();
  }
  document.getElementById("buttonZoomOut").onclick = function() {
    if (iz && incrZ > 0)
      return null;
    incrZ = -zoomIncr;
    iz += fps;
    toggleTimer();
  }
  document.getElementById("buttonZoomIn").onclick = function() {
      if (iz && incrZ < 0)
        return null;
      incrZ = zoomIncr;
      iz += fps;
      toggleTimer();
    }
    //------------------------------------------------------------------------------
  function sinc(x, y) {
    var maxZval = 60
    var mag = sqrt(x * x + y * y)
    var zz = (mag === 0) ? 1 : sin(mag) / mag
      //var zz      = (zz>255) ? 255 : zz
    return -zz * maxZval
  }

  function fn0(x, y) {
    return 0
  }

  function makeGrid(func) {
    var ticMake = +new Date();
    var grid = [];
    var limit = 16 // 1/2 points not including 0
    var xLimit = 3 / limit / 1 // grid endpoints: eg. at -100 ... 100 in metres
    var yLimit = xLimit
    var rowLength = limit * 2 + 1 // rowLength
    var detail = 1 / rowLength
    var count = 0
    var stretch = 100 / limit
    var z
    var zorder = []
    var len = rowLength * rowLength
    for (var x = -limit; x <= limit; x++)
      for (var y = -limit; y <= limit; y++) {
        xx = x * xLimit
        yy = y * yLimit
        z = func(xx, yy)
        zorder.push([count, z])
        grid.push({
          i: count++,
          xx: xx, //not used xcept in bisection
          yy: yy,
          x: x * stretch, // always fill screen at any zoom for same nPoints
          y: y * stretch,
          z: z,
          z4: "",
          _x: 0,
          _y: 0,
          _z: 0,
          az: 0, // z in middle of square

          marker: 0,
          color: ""
        })
      } // grid is finished!

    /// after grid , modify shore:

    cc("length " + grid.length)
    cc('create grid time: ' + (+new Date() - ticMake) + " ms")

    return {
      grid: grid,
      rowLength: rowLength,
      zorder: zorder,
      stretch: stretch,
      xLimit: xLimit,
      fn: func,
      maxZ: Math.max.apply(Math, grid.map(function(o) {
        return o.z;
      })),
      minZ: Math.min.apply(Math, grid.map(function(o) {
        return o.z;
      }))
    }
  }

  function eastWestShoreline(plane) {
    var
      grid = plane.grid,
      func = plane.fn,
      xLimit = plane.xLimit,
      stretch = plane.stretch,
      rowLength = plane.rowLength,
      next_i, z1, z3
    for (var irow = 0; irow < grid.length; irow += rowLength)
      for (var iCol = 0; iCol < rowLength - 2; iCol += 2) {
        i = irow + iCol
        mid = i + 1
        next_i = i + 2
        grid[i].marker = 1
        if (grid[next_i]) {
          z1 = grid[i].z
          z3 = grid[next_i].z
          if (z1 * z3 < 0)
            bisection(i, mid, next_i, grid, func, xLimit, stretch)
          grid[next_i].marker = 2
        }
      }
  }

  function northSouthShoreline(plane) {
    var
      grid = plane.grid,
      func = plane.fn,
      xLimit = plane.xLimit,
      stretch = plane.stretch,
      rowLength = plane.rowLength,
      z1, z3, i, mid, next_i, iCol, iRow
    for (iCol = 0; iCol < rowLength - 2; iCol++) {
      for (iRow = 0; iRow < grid.length; iRow += (rowLength * 2))
        i = iRow + iCol
      mid = i + rowLength
      next_i = mid + rowLength
      grid[i].marker = 1
      if (grid[next_i]) {
        z1 = grid[i].z
        z3 = grid[next_i].z
        if (z1 * z3 < 0)
          bisection(i, mid, next_i, grid, func, xLimit, stretch)
        grid[next_i].marker = 2
      }
    }
  }

  function sortByCol(arr, col) {
    arr.sort(function(a, b) {
      return a[col] - b[col]
    })
  }

  function colors4(plane) {
    var p1, p2, p3, p4,
      grid = plane.grid,
      xLimit = plane.xLimit,
      rowLength = plane.rowLength
    for (var iRow = rowLength; iRow < grid.length; iRow += rowLength)
      for (var iCol = 1; iCol < rowLength; iCol++) {
        var i = iRow + iCol
        p1 = grid[i]
        p2 = grid[i - 1]
        p3 = grid[i - rowLength - 1]
        p4 = grid[i - rowLength]
        p1.color = colorize((p1.z + p2.z + p3.z + p4.z) / 4)
      }
  }

  function colorize2(height) {
    var h = height,
      r, g, b
    if (height < 0) {
      h = floor(-h);
      r = 150;
      g = 150;
      b = 200 + 50
    } else if (height < 100) {
      h = floor(h);
      r = h + 50;
      g = h + 50 + 50;
      b = h + 50
    } else if (height < 200) {
      h = floor(h);
      r = h + 50;
      g = h + 50;
      b = h + 50
    } else {
      h = floor(h);
      r = h;
      g = h;
      b = h
    }
    return "rgb(" + r + "," + g + "," + b + ")"
  }

  function colorize(z) {
    var
      snowLevel = 180,
      seaLevel = 0
    r = z + 0,
      g = z + 30,
      b = z + 0; // green hills
    if (z > snowLevel) {
      r = 180 - z * 2, g = 180 - z * 2, b = 180 - z * 2;
    } //tallest==white
    if (z < seaLevel) {
      r = 240 + z, g = 240 + z, b = 240 + 22;
    } //ocean=blue
    r = round(r)
    g = round(g)
    b = round(b)
    r = (r > 255) ? 255 : r;
    g = (g > 255) ? 255 : g;
    b = (b > 255) ? 255 : b;
    r = (r < 0) ? 0 : r;
    g = (g < 0) ? 0 : g;
    b = (b < 0) ? 0 : b;
    return "rgb(" + r + "," + g + "," + b + ")"
  }

  function updatez(plane) {
    var zorder = plane.zorder
    var p = plane.grid
    for (var i = 0, ii; i < zorder.length; i++) {
      ii = zorder[i][0]
      zorder[i][1] = p[ii]["az"]
    }
    sortByCol(zorder, 1, "reverse");
  }

  function main() {
    if (ix < 1 && iy < 1 && iz < 1) { // check all animation increment countdowns
      clearInterval(timer);
      timer = 0
    }
    if (ix) {
      ix--;
      totalx += incrX
    }
    if (iy) {
      iy--;
      totaly += incrY
    }
    if (iz) {
      iz--;
      totalz += incrZ;
      if (totalz < zMin) totalz = zMin
    }
    plane = world[0]
    grid = plane.grid
    rowLength = plane.rowLength
    var tic1 = +new Date()
    rotateGridPoints(totalx, totaly, grid, totalz, eye, plane.zorder)
    document.getElementById("msgtop3").innerHTML = "rot " + round(+new Date() - tic1)
    updatez(plane)
    paintSquare(ctx, canvas1, grid, rowLength, rowLength, plane.zorder)
      //drawPoints(ctx, canvas1, grid, rowLength, rowLength, plane.zorder)
    document.getElementById("msgtop1").innerHTML = round(1000 / (+new Date() - tic1))
  }

  function drawPoints(ctx, canvas1, grid, rowLength, nRows) {
    ctx.clearRect(0, 0, canvas1.width, canvas1.height);
    ctx.strokeStyle = "grey";
    ctx.beginPath();
    pmiddle = round(rowLength * rowLength / 2)
    for (var row = 0; row < grid.length; row += rowLength) {
      ctx.moveTo(grid[row]._x, grid[row]._y);
      for (var col = 0, i; col < rowLength; col++) {
        i = col + row
        ctx.lineTo(grid[i]._x, grid[i]._y)
          //if ( (i>pmiddle-8)&&  (i<pmiddle+8 ) ) .... round(grid[i].i)+":"+
        if (grid[i].marker === 3)
          ctx.fillText((grid[i].marker), grid[i]._x, grid[i]._y)
      }
    }
    ctx.stroke()
  }

  function paintSquare(ctx, canvas1, grid, rowLength, nRows, zorder) {
    var tic = +new Date()
    ctx.clearRect(0, 0, canvas1.width, canvas1.height);
    ctx.strokeStyle = "grey";
    var p1, p2, p3, p4, pnt //p1 is bottom right of square
    for (var zzi = 0; zzi < zorder.length; zzi++) {
      pnt = zorder[zzi][0]
      if (pnt < rowLength || pnt % rowLength === 0)
        continue
        // if(pnt%rowLength===0) continue
      p1 = grid[pnt]
      p2 = grid[pnt - 1]
      p3 = grid[pnt - rowLength - 1]
      p4 = grid[pnt - rowLength]
      ctx.strokeStyle = 'grey';
      ctx.beginPath();
      ctx.fillStyle = p1.color
      ctx.moveTo(p1._x, p1._y);
      ctx.lineTo(p2._x, p2._y)
      ctx.lineTo(p3._x, p3._y)
      ctx.lineTo(p4._x, p4._y)
      p1.az = (p1._z + p2._z + p3._z + p4._z) / 4; // ☠ update az here because handy
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = "black"
    }
    document.getElementById("msgtop2").innerHTML = (+new Date() - tic)
    updatez(plane)
  }

  function rotateGridPoints(totalx, totaly, grid, totalz, eye, zorder) {
    var
      cosφx = cos(totalx),
      sinφx = sin(totalx),
      cosθy = cos(totaly),
      sinθy = sin(totaly),
      x, y, z, x1, y1, z1, pnt, each, scale;
    for (each = grid.length; each--;) {
      pnt = grid[each]; //global
      x = pnt.x
      y = pnt.y
      z = pnt.z
      x1 = x * cosφx - y * sinφx; //rotate in xy
      y1 = x * sinφx + y * cosφx;
      x = x1
      y = y1
      y1 = y * cosθy - z * sinθy; //rotate in yz
      z1 = y * sinθy + z * cosθy;
      scale = totalz / (1 - z1 / eye)
      pnt._x = centerX + x1 * scale;
      pnt._y = centerY + y1 * scale
      pnt._z = z1 //* scale
        //zorder[each][0]=each
        //zorder[each][1]= pnt._z
    }
  }









  function bisection(i, mid, next_i, grid, func, xLimit, stretch) {
    var p1 = grid[i],
      p2 = grid[mid],
      p3 = grid[next_i],
      x1 = p1.xx,
      xx1 = x1,
      x3 = p3.xx,
      xx3 = x3,
      y1 = p1.yy,
      yy1 = y1,
      y3 = p3.yy,
      yy3 = y3, //copies
      // 38 ... z= 1.23e-12 144 ... eps 2.220446049250313e-16
      iter = 100,
      x2, y2, z1, z2, z3
    while (iter--) {
      x2 = (x1 + x3) / 2
      y2 = (y1 + y3) / 2
      z1 = func(x1, y1)
      z2 = func(x2, y2)
      z3 = func(x3, y3)
      if (z3 * z2 >= 0) { // if z2,z3 are both on same side of zero
        x3 = x2
        y3 = y2
      } else {
        x1 = x2
        y1 = y2
      }
    }
    p2.x = x2 / xLimit * stretch
    p2.y = y2 / xLimit * stretch
    p2.z = z2
    p2.marker = 3
      //p2.color = colorize(p2.z)
      //cc(", z: "+p2.z)
      //cc("---------------------------------------------")
  }









  world = [makeGrid(sinc)]
  colors4(world[0])
  eastWestShoreline(world[0])
  northSouthShoreline(world[0])
  toggleTimer()
  </script>
</body>

</html>
